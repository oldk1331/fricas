)abbrev domain ILIST IndexedList
++ Author: Michael Monagan
++ Date Created: Sep 1987
++ Basic Operations:
++   \#, concat, concat!, construct, copy, elt, empty,
++   empty?, eq?, first, member?, merge!, mergeSort, minIndex,
++   parts, removeDuplicates!, rest, reverse, reverse!,
++   setelt, setfirst!, setrest!, sort!, split!
++ Related Constructors: List
++ Also See:
++ AMS Classification:
++ Keywords: list, aggregate, index
++ Description:
++   \spadtype{IndexedList} is a basic implementation of
++   \spadtype{ListAggregate}, often using functions in the underlying
++   LISP system. The second parameter to the constructor (\spad{mn})
++   is the beginning index of the list. That is, if \spad{l} is a
++   list, then \spad{elt(l, mn)} is the first value.
IndexedList(S : Type, mn : Integer) : ListAggregate S == List S add
    minIndex x == mn
    maxIndex x == mn + # x - 1

)abbrev domain LIST List
++ Author: Michael Monagan
++ Date Created: Sep 1987
++ Basic Operations:
++   \#, append, concat, concat!, cons, construct, copy, elt,
++   empty, empty?, eq?, first, member?, merge!, mergeSort, minIndex,
++   parts, removeDuplicates!, rest, reverse,
++   reverse!, setDifference, setIntersection, setUnion, setelt,
++   setfirst!, setrest!, sort!, split!
++ Related Constructors: ListFunctions2, ListFunctions3, ListToMap
++ Also See: IndexList, ListAggregate
++ AMS Classification:
++ Keywords: list, index, aggregate, lisp
++ Description:
++   \spadtype{List} implements singly-linked lists that are
++   addressable by indices; the index of the first element
++   is 1. In addition to the operations provided by
++   \spadtype{ListAggregate}, this constructor provides some
++   LISP-like functions such as \spadfun{cons} and \spadfun{append}.
List(S : Type) : Exports == Implementation where
 Exports == ListAggregate S with
     cons : (S, %) -> %
         ++ cons(element, l) appends \spad{element} onto the front
         ++ of list \spad{l} and returns the new list. This new list
         ++ and \spad{l} will share some structure.
     append : (%, %) -> %
         ++ append(l1, l2) appends the elements of list \spad{l1}
         ++ onto the front of list \spad{l2}. This new list
         ++ and \spad{l2} will share some structure.
     tails : % -> List %
         ++ tails(l) returns list [rest(l, 0), rest(l, 1), ..., rest(l, #l - 1)]
     if S has BasicType then
         setUnion : (%, %) -> %
             ++ setUnion(l1, l2) appends the two lists \spad{l1} and \spad{l2},
             ++ then removes all duplicates. The order of elements in the
             ++ resulting list is unspecified.
         setIntersection : (%, %) -> %
             ++ setIntersection(l1, l2) returns a list of the elements
             ++ that \spad{l1} and \spad{l2} have in common.
             ++ The order of elements in the resulting list is unspecified.
         setDifference : (%, %) -> %
             ++ setDifference(l1, l2) returns a list of the elements
             ++ of \spad{l1} that are not in \spad{l2}.
             ++ The order of elements in the resulting list is unspecified.
     if S has OpenMath then OpenMath

 Implementation == add
     LISTMININDEX ==> 1 -- this is the minimum list index
     cycleMax ==> 1000 -- value used in checking for cycles
     Qfirst x ==> (CAR(x)$Lisp)@S

     -- functions to construct a list

     empty() == NIL$Lisp
     empty? x == NULL(x)$Lisp

     cons(s, x) == CONS(s, x)$Lisp
     concat(s : S, x : %) == cons(s, x)

     list s == LIST(s)$Lisp
     new(n, s) == makeList(n, s)$Lisp
     construct l == l pretend %

     -- functions to inspect a list

     first x == SPADfirst(x)$Lisp
     elt(x, "first") == first x

     rest x == CDR(x)$Lisp
     elt(x, "rest") == rest x

     second x == first rest x
     third x == first rest rest x

     -- functions to modify a list

     qsetfirst!(x, s) == qset_first(x, s)$Lisp
     qsetrest!(x, y) == qset_rest(x, y)$Lisp

     SETELT(x, s, f) ==>
         empty? x => error "Cannot update an empty list"
         f(x, s)
     setfirst!(x, s) == SETELT(x, s, qsetfirst!)
     setelt!(x, "first", s) == SETELT(x, s, qsetfirst!)
     setrest!(x, y) == SETELT(x, y, qsetrest!)
     setelt!(x, "rest", y) == SETELT(x, y, qsetrest!)

     -- functions that can be inlined

     # x == LENGTH(x)$Lisp
     eq?(x, y) == EQ(x, y)$Lisp
     minIndex x == LISTMININDEX
     maxIndex x == # x

     parts x == x pretend List S
     members x == parts x
     entries x == parts x

     append(x, y) == APPEND(x, y)$Lisp
     concat(x : %, y : %) == append(x, y)

     reverse x == REVERSE(x)$Lisp
     reverse! x == NREVERSE(x)$Lisp

     -- other functions

     less?(l, n) ==
         i := n::Integer
         while i > 0 and not empty? l repeat (l := rest l; i := i - 1)
         i > 0

     more?(l, n) ==
         i := n::Integer
         while i > 0 and not empty? l repeat (l := rest l; i := i - 1)
         zero? i and not empty? l

     size?(l, n) ==
         i := n::Integer
         while i > 0 and not empty? l repeat (l := rest l; i := i - 1)
         zero? i and empty? l

     last x == if empty? x then error "empty list" else last(x)$Lisp
     tail x == if empty? x then error "empty list" else LASTTAIL(x)$Lisp

     rest(x, n) ==
         for i in 1..n repeat
             if empty? x then error "index out of range"
             x := rest x
         x

     tails x ==
         [rest(x, i) for i in 0..(#x - 1)]

     copy x ==
         y : % := empty()
         for i in 0.. while not empty? x repeat
             if i = cycleMax and cyclic? x then error "cyclic list"
             y := cons(Qfirst x, y)
             x := rest x
         reverse! y

     concat!(x : %, y : %) ==
         empty? x => y
         z := x
         while not empty? rest z repeat
             z := rest z
         qsetrest!(z, y)
         x

     leaves x ==
         empty? x => empty()
         for i in 0.. while not empty? x repeat
             i = cycleMax and cyclic? x => error "cyclic list"
             leaf? x => return [value x]
             x := rest x

     if S has BasicType then
         x = y ==
             eq?(x, y) => true
             while not empty? x and not empty? y repeat
                 Qfirst x ~=$S Qfirst y => return false
                 x := rest x
                 y := rest y
             empty? x and empty? y

         member?(s, x) ==
             while not empty? x repeat
                 if s = Qfirst x then return true else x := rest x
             false

         removeDuplicates! l ==
             p := l
             while not empty? p repeat
                 pp := p
                 f := Qfirst p
                 p := rest p
                 while not empty?(pr := rest pp) repeat
                     if Qfirst pr = f then qsetrest!(pp, rest pr)
                     else pp := pr
             l

         map!(f, l) ==
             y := l
             while not empty? l repeat
                 qsetfirst!(l, f Qfirst l)
                 l := rest l
             y

         setUnion(l1 : %, l2 : %) == removeDuplicates concat(l1, l2)

         setIntersection(l1 : %, l2 : %) ==
             lu : % := empty()
             empty? l2 => lu
             l1 := removeDuplicates l1
             while not empty? l1 repeat
                 s1 := Qfirst l1
                 if member?(s1, l2) then lu := cons(s1, lu)
                 l1 := rest l1
             lu

         setDifference(l1 : %, l2 : %) ==
             l1 := removeDuplicates l1
             empty? l2 => l1
             lu : % := empty()
             while not empty? l1 repeat
                 s1 := Qfirst l1
                 if not member?(s1, l2) then lu := cons(s1, lu)
                 l1 := rest l1
             lu

     if S has ConvertibleTo InputForm then
         convert(x : %) : InputForm ==
             convert concat(convert('construct)@InputForm,
                 [convert a for a in (x pretend List S)]$List(InputForm))

     if S has CoercibleTo OutputForm then
         coerce(x) : OutputForm ==
             -- displays cycle with overbar over the cycle
             y : List(OutputForm) := []
             s := cycleEntry x
             while not eq?(x, s) repeat
                 y := concat((first x)::OutputForm, y)
                 x := rest x
             y := reverse! y
             empty? s => bracket y
             -- cyclic case: z is cyclic part
             z := [(first x)::OutputForm]
             while not eq?(s, rest x) repeat
                 x := rest x
                 z := concat((first x)::OutputForm, z)
             bracket concat!(y, overbar commaSeparate reverse! z)

     if S has SetCategory then
         latex(x : %) : String ==
             s : String := "\left["
             while not empty? x repeat
                 s := concat(s, latex(Qfirst x)$S)$String
                 x := rest x
                 if not empty? x then s := concat(s, ", ")$String
             concat(s, " \right]")$String

         hashUpdate!(s : HashState, x : %) : HashState ==
             while not empty? x repeat
                 s := hashUpdate!(s, Qfirst x)
                 x := rest x
             s

     if S has OpenMath then
         writeOMList(dev : OpenMathDevice, x : %) : Void ==
             OMputApp(dev)
             OMputSymbol(dev, "list1", "list")
             -- The following didn't compile because the compiler isn't
             -- convinced that `xval' is a S.  Duhhh! MCD.
             --for xval in x repeat
             --  OMwrite(dev, xval, false)
             while not empty?(x) repeat
                 OMwrite(dev, first x, false)
                 x := rest x
             OMputEndApp(dev)

         OMwrite(dev : OpenMathDevice, x : %, wholeObj : Boolean) : Void ==
             if wholeObj then
                 OMputObject(dev)
             writeOMList(dev, x)
             if wholeObj then
                 OMputEndObject(dev)

     mergeSort : ((S, S) -> Boolean, %, Integer) -> %

     sort!(f, l) == mergeSort(f, l, #l)

     merge!(f, p, q) ==
         empty? p => q
         empty? q => p
         eq?(p, q) => error "cannot merge a list into itself"
         if f(Qfirst p, Qfirst q)
             then (r := t := p; p := rest p)
             else (r := t := q; q := rest q)
         while not empty? p and not empty? q repeat
             if f(Qfirst p, Qfirst q)
                 then (qsetrest!(t, p); t := p; p := rest p)
                 else (qsetrest!(t, q); t := q; q := rest q)
         qsetrest!(t, if empty? p then q else p)
         r

     split!(p, n) ==
         n = 0 =>
             empty? p => empty()
             error "split!: can not set argument to empty()"
         empty? p => error "split!: argument is empty()"
         p := rest(p, (n - 1)::NonNegativeInteger)
         empty? p => error "split!: index out of range"
         q := rest p
         qsetrest!(p, empty())
         q

     mergeSort(f, p, n) ==
         if n = 2 and f(Qfirst rest p, Qfirst p) then p := reverse! p
         n < 3 => p
         l := (n quo 2)::NonNegativeInteger
         q := split!(p, l)
         p := mergeSort(f, p, l)
         q := mergeSort(f, q, n - l)
         merge!(f, p, q)

)abbrev package LIST2 ListFunctions2
++ Author:
++ Basic Operations: map, reduce, scan
++ Related Constructors: List
++ Also See: ListFunctions3
++ AMS Classification:
++ Keywords: list, aggregate, map, reduce
++ Description:
++   \spadtype{ListFunctions2} implements utility functions that
++   operate on two kinds of lists, each with a possibly different
++   type of element.
ListFunctions2(A : Type, B : Type) : public == private where
  LA     ==> List A
  LB     ==> List B
  O2     ==> FiniteLinearAggregateFunctions2(A, LA, B, LB)

  public ==> with
    scan :    ((A, B) -> B, LA, B) -> LB
      ++ scan(fn, u, ident) successively uses the binary function
      ++ \spad{fn} to reduce more and more of list \spad{u}.
      ++ \spad{ident} is returned if the \spad{u} is empty.
      ++ The result is a list of the reductions at each step. See
      ++ \spadfun{reduce} for more information. Examples:
      ++ \spad{scan(fn, [1, 2], 0) = [fn(2, fn(1, 0)), fn(1, 0)]} and
      ++ \spad{scan(*, [2, 3], 1) = [2 * 1, 3 * (2 * 1)]}.
    reduce :  ((A, B) -> B, LA, B) -> B
      ++ reduce(fn, u, ident) successively uses the binary function
      ++ \spad{fn} on the elements of list \spad{u} and the result
      ++ of previous applications. \spad{ident} is returned if the
      ++ \spad{u} is empty. Note the order of application in
      ++ the following examples:
      ++ \spad{reduce(fn, [1, 2, 3], 0) = fn(3, fn(2, fn(1, 0)))} and
      ++ \spad{reduce(*, [2, 3], 1) = 3 * (2 * 1)}.
    map :      (A -> B, LA) -> LB
      ++ map(fn, u) applies \spad{fn} to each element of
      ++ list \spad{u} and returns a new list with the results.
      ++ For example \spad{map(square, [1, 2, 3]) = [1, 4, 9]}.

  private ==> add
    map(f, l)       == map(f, l)$O2
    scan(f, l, b)   == scan(f, l, b)$O2
    reduce(f, l, b) == reduce(f, l, b)$O2

)abbrev package LIST3 ListFunctions3
++ Author:
++ Basic Operations: map
++ Related Constructors: List
++ Also See: ListFunctions2
++ AMS Classification:
++ Keywords: list, aggregate, map
++ Description:
++   \spadtype{ListFunctions3} implements utility functions that
++   operate on three kinds of lists, each with a possibly different
++   type of element.
ListFunctions3(A : Type, B : Type, C : Type) : public == private where
  LA     ==> List A
  LB     ==> List B
  LC     ==> List C

  public ==> with
    map : ((A, B) -> C, LA, LB) -> LC
      ++ map(fn, u1, u2) applies the binary function \spad{fn}
      ++ to corresponding elements of lists \spad{u1} and \spad{u2}
      ++ and returns a list of the results (in the same order). Thus
      ++ \spad{map(/, [1, 2, 3], [4, 5, 6]) = [1/4, 2/5, 1/2]}. The computation
      ++ terminates when the end of either list is reached. That is,
      ++ the length of the result list is equal to the minimum of the
      ++ lengths of \spad{u1} and \spad{u2}.

  private ==> add
    map(fn : (A, B) -> C, la : LA, lb : LB) : LC ==
        [fn(a, b) for a in la for b in lb]

)abbrev package LIST2MAP ListToMap
++ Author: Manuel Bronstein
++ Date Created: 22 Mar 1988
++ Basic Operations: match
++ Related Constructors: List
++ Also See:
++ AMS Classification:
++ Keywords: mapping, list
++ Description:
++   \spadtype{ListToMap} allows mappings to be described by a pair of
++   lists of equal lengths.  The image of an element \spad{x},
++   which appears in position \spad{n} in the first list, is then
++   the \spad{n}th element of the second list.  A default value or
++   default function can be specified to be used when \spad{x}
++   does not appear in the first list.  In the absence of defaults,
++   an error will occur in that case.
ListToMap(A : SetCategory, B : Type) : Exports == Implementation where
  LA  ==> List A
  LB  ==> List B
  AB  ==> (A -> B)

  Exports ==> with
    match : (LA, LB) -> AB
      ++ match(la, lb) creates a map with no default source or target values
      ++ defined by lists la and lb of equal length.
      ++ The target of a source value \spad{x} in la is the
      ++ value y with the same index in lb.
      ++ Error: if la and lb are not of equal length.
      ++ Note: when this map is applied, an error occurs when
      ++ applied to a value missing from la.
    match : (LA, LB, A) -> B
      ++ match(la, lb, a) creates a map
      ++ defined by lists la and lb of equal length, where \spad{a} is used
      ++ as the default source value if the given one is not in \spad{la}.
      ++ The target of a source value \spad{x} in la is the
      ++ value y with the same index in lb.
      ++ Error: if la and lb are not of equal length.
    match : (LA, LB, B)    -> AB
      ++ match(la, lb, b) creates a map
      ++ defined by lists la and lb of equal length, where \spad{b} is used
      ++ as the default target value if the given function argument is
      ++ not in \spad{la}.
      ++ The target of a source value \spad{x} in la is the
      ++ value y with the same index in lb.
      ++ Error: if la and lb are not of equal length.
    match : (LA, LB, A, B) -> B
      ++ match(la, lb, a, b) creates a map
      ++ defined by lists la and lb of equal length.
      ++ and applies this map to a.
      ++ The target of a source value \spad{x} in la is the
      ++ value y with the same index in lb.
      ++ Argument b is the default target value if a is not in la.
      ++ Error: if la and lb are not of equal length.
    match : (LA, LB, AB)    -> AB
      ++ match(la, lb, f) creates a map
      ++ defined by lists la and lb of equal length.
      ++ The target of a source value \spad{x} in la is the
      ++ value y with the same index in lb.
      ++ Argument \spad{f} is used as the
      ++ function to call when the given function argument is not in
      ++ \spad{la}.
      ++ The value returned is f applied to that argument.
    match : (LA, LB, A, AB) -> B
      ++ match(la, lb, a, f) creates a map
      ++ defined by lists la and lb of equal length.
      ++ and applies this map to a.
      ++ The target of a source value \spad{x} in la is the
      ++ value y with the same index in lb.
      ++ Argument \spad{f} is a default function to call if a is not in la.
      ++ The value returned is then obtained by applying f to argument a.

  Implementation ==> add
    match(la, lb)             == (z1 : A) : B +-> match(la, lb, z1)
    match(la : LA, lb : LB, a : A)  == lb.position(a, la)
    match(la : LA, lb : LB, b : B)  == (z1 : A) : B +-> match(la, lb, z1, b)
    match(la : LA, lb : LB, f : AB) == (z1 : A) : B +-> match(la, lb, z1, f)

    match(la : LA, lb : LB, a : A, b : B) ==
      (p := position(a, la)) < minIndex(la) => b
      lb.p

    match(la : LA, lb : LB, a : A, f : AB) ==
      (p := position(a, la)) < minIndex(la) => f a
      lb.p

)abbrev domain ALIST AssociationList
++ Author:
++ Basic Operations: empty, empty?, keys, \#, concat, first, rest,
++   setrest!, search, setelt, remove!
++ Related Constructors:
++ Also See: List
++ AMS Classification:
++ Keywords: list, association list
++ Description:
++   \spadtype{AssociationList} implements association lists. These
++   may be viewed as lists of pairs where the first part is a key
++   and the second is the stored value. For example, the key might
++   be a string with a persons employee identification number and
++   the value might be a record with personnel data.

AssociationList(Key : SetCategory, Entry : Type):
 AssociationListAggregate(Key, Entry) == add
        Pair ==> Record(key : Key, entry : Entry)
        Rep := Reference List Pair

        import from List Pair

        dictionary()            == ref empty()
        empty()                 == dictionary()
        empty? t                == empty? deref t
        entries(t : %) : List(Pair) == deref t
        parts(t : %) : List(Pair)   == deref t
        keys t                  == [k.key for k in deref t]
        # t                     == # deref t
        first(t : %) : Pair         == first deref t
        rest t                  == ref rest deref t
        concat(p : Pair, t : %)     == ref concat(p, deref t)
        setrest!(a : %, b : %)     == ref setrest!(deref a, deref b)
        setfirst!(a : %, p : Pair) == setfirst!(deref a, p)
        minIndex(a : %) : Integer   == minIndex(deref a)
        maxIndex(a : %) : Integer   == maxIndex(deref a)

        search(k, t) ==
          for r in deref t repeat
            k = r.key => return(r.entry)
          "failed"
        copy l == ref [[r.key, r.entry] for r in deref l]

        if Entry has SetCategory then
            latex(a : %) : String ==
                l : List Pair := entries a
                s : String := "\left["
                while not empty?(l) repeat
                    r : Pair := first l
                    l        := rest l
                    s := concat(s, concat(latex r.key, concat(" = ",
                            latex r.entry)$String)$String)$String
                    if not empty?(l) then s := concat(s, ", ")$String
                concat(s, " \right]")$String

--      assoc(k, l) ==
--        (r := find(#1.key=k, l)) case "failed" => "failed"
--        r

        assoc(k, t) ==
          for r in deref t repeat
            k = r.key => return r
          "failed"

        setelt!(t : %, k : Key, e : Entry) ==
          (r := assoc(k, t)) case Pair => (r::Pair).entry := e
          setref(t, concat([k, e], deref t))
          e

        remove!(k : Key, t : %) ==
          empty?(l := deref t) => "failed"
          k = first(l).key =>
            setref(t, rest l)
            first(l).entry
          prev := l
          curr := rest l
          while not empty? curr and first(curr).key ~= k repeat
            prev := curr
            curr := rest curr
          empty? curr => "failed"
          setrest!(prev, rest curr)
          first(curr).entry

)abbrev domain DLLIST DoublyLinkedList
DoublyLinkedList(S : Type) : Exports == Implementation where
  Exports == Join(DoublyLinkedAggregate S, Collection S, shallowlyMutable,
                  finiteAggregate) with
    dllist : List S -> %
    dllist : S -> %
    concat! : (S, %) -> %
    concat : (%, %) -> %
    first : % -> S
    first : (%, Integer) -> List S
    reverse : % -> %
    reverse! : % -> %
    new : (NonNegativeInteger, S) -> %
    split! : (%, Integer) -> %
    next : (%, Integer) -> %
    previous : (%, Integer) -> %
    merge! : ((S, S) -> Boolean, %, %) -> %
    sort : % -> %
    sort! : ((S, S) -> Boolean, %) -> %
  Implementation == add
    Rep := Record(prev : %, val : S, next : %)

    empty() == NIL$Lisp

    empty? x == NULL(x)$Lisp

    emptyErrMsg ==> "DoublyLinkedList : argument is empty"

    eq?(u, v) == EQ(u, v)$Lisp

    dllist(s : S) ==
        l : % := [empty(), s, empty()]
        l.prev := l
        l.next := l
        l

    first x ==
        empty? x => error emptyErrMsg
        x.val

    first(x, n) ==
        n = 0 => []
        empty? x => error emptyErrMsg
        res : List S := []
        n > 0 =>
            while n ~= 0 repeat
                res := concat(x.val, res)
                x := x.next
                n := n - 1
            reverse! res
        -- n < 0
        while n ~= 0 repeat
            res := concat(x.val, res)
            x := x.prev
            n := n + 1
        reverse! res

    value x == first x

    next x ==
        empty? x => error emptyErrMsg
        x.next

    next(x : %, n : Integer) : % ==
        n = 0 => x
        empty? x => error emptyErrMsg
        n > 0 =>
            for i in 1..n repeat
                x := x.next
            x
        for i in n..-1 repeat
            x := x.prev
        x

    previous x ==
        empty? x => error emptyErrMsg
        x.prev

    previous(x : %, n : Integer) : % ==
        n = 0 => x
        empty? x => error emptyErrMsg
        n < 0 =>
            for i in n..-1 repeat
                x := x.next
            x
        for i in 1..n repeat
            x := x.prev
        x

    setnext!(x, n) ==
        empty? x => error emptyErrMsg
        x.next := n

    setprevious!(x, p) ==
        empty? x => error emptyErrMsg
        x.prev := p

    setvalue!(x, v) ==
        empty? x => error emptyErrMsg
        x.val := v

    setchildren!(x, l) ==
        error "setchildren! is not well defined in DoublyLinkedList"

    _connect(tail : %, head : %) : Void ==
        -- connect the node 'tail' and 'head'
        tail.next := head
        head.prev := tail

    copy x ==
        empty? x => empty()
        x0 := x
        res : % := [empty(), x0.val, empty()]
        tail := res
        x := x.next
        while not eq?(x0, x) repeat
            new : % := [tail, x.val, empty()]
            tail.next := new
            tail := new
            x := x.next
        _connect(tail, res)
        res

    map(f, x) ==
        empty? x => empty()
        x0 := x
        res : % := [empty(), f x0.val, empty()]
        tail := res
        x := x.next
        while not eq?(x0, x) repeat
            new : % := [tail, f x.val, empty()]
            tail.next := new
            tail := new
            x := x.next
        _connect(tail, res)
        res

    map!(f, x) ==
        empty? x => empty()
        x0 := x
        repeat
            x.val := f x.val
            x := x.next
            eq?(x0, x) => return x

    # x == -- should we encode length in the Rep, just like C++?
        empty? x => 0
        x0 := x
        len := 0
        repeat
            x := x.next
            len := len + 1
            eq?(x0, x) => return len

    less?(x, n) ==
         empty? x => 0 < n
         x0 := x
         i : Integer := n
         while i > 0 repeat
             x := x.next
             i := i - 1
             eq?(x0, x) => return i > 0
         i > 0

    more?(x, n) ==
        empty? x => false
        x0 := x
        i : Integer := n
        while i > 0 repeat
            x := x.next
            i := i - 1
            eq?(x0, x) => return false
        true

    size?(x, n) ==
        empty? x => n = 0
        x0 := x
        i : Integer := n
        while i > 0 repeat
            x := x.next
            i := i - 1
            eq?(x0, x) => return i = 0
        eq?(x0, x)

    concat!(s : S, x : %) : % ==
        empty? x => dllist s
        tail := x.prev
        new : % := [tail, s, x]
        tail.next := new
        x.prev := new
        new

    dllist(l : List S) : % ==
        empty? l => empty()
        res : % := [empty(), first l, empty()]
        tail := res
        l := rest l
        while not empty? l repeat
            new : % := [tail, first l, empty()]
            tail.next := new
            tail := new
            l := rest l
        _connect(tail, res)
        res

    new(n : NonNegativeInteger, s : S) : % ==
        n = 0 => empty()
        res : % := [empty(), s, empty()]
        tail := res
        for i in 1.. while i < n repeat
            new : % := [tail, s, empty()]
            tail.next := new
            tail := new
        _connect(tail, res)
        res

    -- 'parts' preserves order
    parts x ==
        empty? x => empty()
        x0 := x
        res : List S := []
        repeat
            x := x.prev
            res := concat(x.val, res)
            eq?(x0, x) => return res

    reverse x ==
        empty? x => empty()
        x0 := x.prev
        x := x0.prev
        res : % := [empty(), x0.val, empty()]
        tail := res
        while not eq?(x0, x) repeat
            new : % := [tail, x.val, empty()]
            tail.next := new
            tail := new
            x := x.prev
        _connect(tail, res)
        res

    reverse! x ==
        empty? x => empty()
        x0 := x.prev
        eq?(x0, x) => x
        p := x0
        repeat
            n := x.next
            x.next := p
            x.prev := n
            eq?(x, x0) => return x0
            p := x
            x := n

    concat(u : %, v : %) ==
        empty? v => u
        empty? u => v
        concat!(copy u, copy v)

    concat!(u : %, v : %) : % ==
        empty? v => u
        empty? u => v
        uend := u.prev
        vend := v.prev
        _connect(uend, v)
        _connect(vend, u)
        u

    split!(x : %, n : Integer) : % ==
        n = 0 =>
            empty? x => empty()
            error "split!: can not set argument to empty()"
        empty? x => error "split!: argument is empty()"
        xn := next(x, n)
        eq?(x, xn) => empty()
        xend := xn.prev
        xnend := x.prev
        _connect(xend, x)
        _connect(xnend, xn)
        xn

    children x ==
        empty? x => []
        [x.prev, x.next]

    nodes x ==
        empty? x => []
        res : List % := []
        x0 := x
        x := x.prev
        repeat
            res := concat(x, res)
            eq?(x0, x) => return res
            x := x.prev

    leaf? x == false

    leaves x == []

    child?(u, v) ==
        empty? u or empty? v => false
        eq?(u, v.next) or eq?(u, v.prev)

    node?(u, v) ==
        empty? u or empty? v => false
        v0 := v
        repeat
            eq?(u, v) => return true
            v := v.next
            eq?(v0, v) => return false

    distance(u, v) ==
        empty? u or empty? v => -1
        u0 := u
        res := 0
        repeat
            eq?(u, v) => return res
            u := u.next
            res := res + 1
            eq?(u0, u) => return -1

    last(x : %) : S ==
        empty? x => error emptyErrMsg
        x.prev.val

    any?(f : S -> Boolean, x : %) : Boolean ==
        empty? x => false
        x0 := x
        repeat
            f x.val => return true
            x := x.next
            eq?(x0, x) => return false

    every?(f : S -> Boolean, x : %) : Boolean ==
        empty? x => true
        x0 := x
        repeat
            not f x.val => return false
            x := x.next
            eq?(x0, x) => return true

    merge1!(f : (S, S) -> Boolean, p : %, q : %) : % ==
        -- merge1! is a local function used inside function 'merge!'.
        -- The argument p has exactly 1 element,
        -- and q is guaranteed to be non-empty.
        qend := q.prev
        -- Insert p at beginning of q is a little different:
        -- it returns p instead of q0.
        f(p.val, q.val) =>
            _connect(p, q)
            _connect(qend, p)
            p
        q0 := q
        q := q.next
        while not eq?(q0, q) and not f(p.val, q.val) repeat
            q := q.next
        _connect(p, q)
        _connect(qend, p)
        q0

    merge!(f, p, q) ==
        empty? p => q
        empty? q => p
        eq?(p, q) => error "can not merge a list into itself"
        -- we have to handle lists with 1 element specially
        size?(p, 1) => merge1!(f, p, q)
        size?(q, 1) => merge1!(f, q, p)
        p0 := p; pend := p0.prev
        q0 := q; qend := q0.prev
        if f(p.val, q.val)
            then (r := t := p; p := p.next)
            else (r := t := q; q := q.next)
        repeat
            if f(p.val, q.val)
            then
                if not eq?(t.next, p) then
                    _connect(t, p)
                t := p
                p := p.next
            else
                if not eq?(t.next, q) then
                    _connect(t, q)
                t := q
                q := q.next
            eq?(p0, p) or eq?(q0, q) => break
        eq?(p0, p) =>
            if not eq?(t.next, q) then
                _connect(t, q)
            _connect(qend, r)
            r
        eq?(q0, q) =>
            if not eq?(t.next, p) then
                _connect(t, p)
            _connect(pend, r)
            r

    ----------------------------
    -- SORT
    ----------------------------
    -- __unlink, __link, __sort, __merge are local functions
    -- used in function 'sort!'.

    __unlink(f : %, l : %) : Void ==
        -- Cut off from 'f' to 'l' (both nodes are included).
        f.prev.next := l.next
        l.next.prev := f.prev

    __link(p : %, f : %, l : %) : Void ==
        -- Link in nodes from 'f' to 'l' just prior to 'p'.
        p.prev.next := f
        f.prev := p.prev
        p.prev := l
        l.next := p

    __merge : ((S, S) -> Boolean, %, %, %) -> %
    -- __merge(comp, f1, e1, e2)
    -- merge from f1 to e1 (not included) and e1 to e2 (not included).
    -- distance(f1, e1) and distance(e1, e2) is at least 1.

    __sort : ((S, S) -> Boolean, %, %, Integer) -> %
    -- __sort(comp, f1, e2, n)
    -- sort from node f1 to node e2 (not included).

    sort!(f : (S, S) -> Boolean, x : %) : % ==
    -- https://github.com/llvm-mirror/libcxx/blob/88626bf496e9a1276652790438b389e65950629f/include/list#L2233
    -- The following code does some initialization: computes the length of 'x',
    -- and gets the pointer 'xhalf' that points to the middle of 'x'.
    -- The actual sorting is done by '__sort' and '__merge'.
        empty? x => empty()
        x0 := x
        x := x.next
        eq?(x0, x) => x0
        eq?(x0, x.next) =>
            -- length is 2
            f(x0.val, x.val) => x0
            x
        len := 2
        xhalf := x
        x := x.next
        repeat
            len := len + 1
            x := x.next
            if even? len then xhalf := xhalf.next
            eq?(x0, x) => break
        lhalf := len quo 2
        x0 := __sort(f, x0, xhalf, lhalf)
        xhalf := __sort(f, xhalf, x0, len - lhalf)
        __merge(f, x0, xhalf, x0)

    __sort(comp, f1, e2, n) ==
        -- __sort(comp, f1, e2, n) sorts through node 'f1' to
        -- node 'e2' (not included). There are 'n' nodes between them.
        -- This function returns 'f1'.
        n = 1 => f1
        n = 2 =>
            e2 := f1.next
            comp(f1.val, e2.val) => f1
            (f1.val, e2.val) := (e2.val, f1.val)
            f1
        n2 := n quo 2
        e1 := next(f1, n2)
        f1 := __sort(comp, f1, e1, n2)
        e1 := __sort(comp, e1, e2, n - n2)
        __merge(comp, f1, e1, e2)

    __merge(comp : (S, S) -> Boolean, f1 : %, e1 : %, e2 : %) : % ==
        -- r is the pointer that will be returned.
        r := f1
        -- f2 is the beginning of second segment,
        -- which is also the end of first segment.
        f2 := e1
        -- The following if expression determines the beginning of
        -- sorted segment.
        if comp(f2.val, f1.val) then
            m2 := f2.next
            while not eq?(m2, e2) and comp(m2.val, f1.val) repeat
                m2 := m2.next
            f := f2
            l := m2.prev
            r := f2
            e1 := f2 := m2
            __unlink(f, l)
            m2 := f1.next
            __link(f1, f, l)
            f1 := m2
        else
            f1 := f1.next
        while not eq?(f1, e1) and not eq?(f2, e2) repeat
            if comp(f2.val, f1.val) then
                m2 := f2.next
                while not eq?(m2, e2) and comp(m2.val, f1.val) repeat
                    m2 := m2.next
                f := f2
                l := m2.prev
                if eq?(e1, f2) then e1 := m2
                f2 := m2
                __unlink(f, l)
                m2 := f1.next
                __link(f1, f, l)
                f1 := m2
            else
                f1 := f1.next
        r

    if S has BasicType then
        u = v ==
            empty? v => empty? u
            empty? u => false
            v0 := v; u0 := u
            repeat
                u.val ~= v.val => return false
                u := u.next; v := v.next
                eq?(u0, u) => return eq?(v0, v)
                eq?(v0, v) => return eq?(u0, u)

        member?(s : S, x : %) : Boolean ==
            empty? x => false
            x0 := x
            repeat
                s = x.val => return true
                x := x.next
                eq?(x0, x) => return false

        count(s : S, x : %) : NonNegativeInteger ==
            empty? x => 0
            x0 := x
            res := 0
            repeat
                if s = x.val then res := res + 1
                x := x.next
                eq?(x0, x) => return res

    if S has CoercibleTo OutputForm then
        coerce(x : %) : OutputForm ==
            parts(x)::OutputForm

    if S has SetCategory then
        hashUpdate!(s : HashState, x : %) : HashState ==
            empty? x => s
            x0 := x
            repeat
                s := hashUpdate!(s, x.val)
                x := x.next
                eq?(x0, x) => return s


--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
